---
layout: post
title: 【读书笔记】《程序员的自我修养：链接、装载与库》
tags: [note, programming]
---

# 目录

1. [简介](#introduction)
2. [静态链接](#static_linking)
3. [装载与动态链接](#dynamic_linking)
4. [库与运行库](#runtime_library)
5. [索引](#index)

<h1 id="introduction"> 第1部分 简介 </h1>

## 1.1 计算机系统

### 硬件部分

- 对于系统程序开发者来说，计算机多如牛毛的硬件设备中，有三个部件最为关键，它们分别是**中央处理器CPU、内存和I/O控制芯片**
- 北桥连接所有高速芯片，南桥连接所有低速芯片
- 北桥采用过的总线结构有PCI、AGP或PCI Express等
- 除非想把CPU的每一滴油水都榨干，否则可以把多核处理器和对称多处理器(SMP)看成同一个概念

### 软件部分

#### 系统软件

- P.8 “计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决”
- 每个层次之间都需要相互通信，既然需要通信就必须有一个通信的协议，我们一般将其称为**接口**（Interface）
- **应用程序编程接口**（Application Programming Interface）
- 运行库使用操作系统提供的**系统调用接口**（System Call Interface）
  - 系统调用接口在实现中往往以**软件中断**（Software Interrupt）的方式提供

#### 操作系统

- 充分挖掘CPU潜力
  - 早期：**多道程序**的方法--监控程序监控CPU资源
  - 协作的模式：**分时系统**
  - 现代：**多任务系统**--所有应用程序都以**进程**的方式运行在比操作系统权限更低的级别，CPU分配方式为**抢占式**（Preemptive）
- I/O设备
  - 硬件管理交给**硬件驱动程序**（Device Driver）来完成
  - UNIX系统中，硬件设备的访问形式跟访问普通的文件形式一样
  - Windows系统中，图形硬件被抽象成了GDI，声音和多媒体设备被抽象成了DirectX对象，磁盘被抽象成了普通文件系统
  - 文件系统：硬盘基本存储单位为**扇区**（Sector），向硬盘发送I/O命令的方式有很多种，其中最为常见的一种就是通过读写I/O端口寄存器来实现
- 内存
  - 在早期的计算机中，程序是直接运行在物理内存上的。在将有限的物理内存分配给多个程序使用时，会带来三个问题：1. 地址空间不隔离 2. 内存使用效率低 3. 程序运行的地址不确定（涉及重定位的问题）
  - 解决问题的思路是增加中间层：将程序给出的地址看作是**虚拟地址**（Virtual Address），然后映射到物理地址
  - **分段**（Segmentation）：采用段映射机制，将程序所需的虚拟内存空间整段映射到物理内存空间
  - **分页**（Paging）：分页的基本方法是把地址空间人为地等分成固定大小的页，目前几乎所有PC上的操作系统都使用4KB大小的页
    - **虚拟页**（VP, Virtual Page），**物理页**（PP, Physical Page），**磁盘页**（DP, Disk Page）
    - 可以通过内存共享机制解决内存使用效率低的问题
    - 保护也是页映射的目的之一，简单地说就是每个页可以设置权限属性，只有操作系统有权限修改这些属性
    - 虚拟存储的实现需要依靠硬件的支持，几乎所有CPU都采用MMU(Memory Management Unit)将虚拟地址转换成物理地址

#### 多线程

- 线程的概念
  - 线程是程序执行的最小单元
  - 一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成
  - 各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级的资源（如打开文件和信号）
  - Windows对进程和线程的实现如同教科书一般标准，而Linux对多线程的支持颇为贫乏
- 线程的访问权限
  - 线程的私有存储空间包括以下几个方面
    - 栈（尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有的数据）
    - 线程局部存储（Thread Local Storage）
    - 寄存器（包括PC寄存器）
  - 从C程序员的角度来看，数据在线程之间是否私有如表1-1所示
  ![Thread_Specific_Data](/public/img/linkers/Thread_Specific_Data.jpg)
- 线程调度与优先级
  - 不断在处理器上切换不同的线程的行为称之为**线程调度**（Thread Schedule）
  - 在线程调度中，线程通常至少有三种状态：运行、就绪、等待
  - 处于运行中线程拥有一段可以执行的时间，这段时间称为**时间片**（Time Slice）
  - 线程调度有不同的方案和算法，现在主流的方法都带有**优先级调度**（Priority Schedule）和**轮转法**（Round Robin）的痕迹
  - **IO密集型线程**：频繁等待的线程；**CPU密集型线程**：很少等待的线程
  - 可抢占线程和不可抢占线程：线程在用尽时间片后被强制剥夺继续执行的权力，这个过程叫做**抢占**（Preemption）
- 线程安全
  - 原子操作：编译成汇编代码之后单指令的操作称为**原子**（Atomic）操作
  - 同步：在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问
  - 同步的最常见方法是使用锁
    - 二元信号量（Binary Semaphore）是最简单的一种锁，它只有两种状态：占用和非占用
    - 多元信号量：一个初始值为N的信号量允许N个线程并发访问
    - 互斥量（Mutex）和二元信号量类似，但是互斥量只允许获取它的线程释放它
    - 临界区（Critical Section）是比互斥量更加严格的同步手段，它只在本进程可见；互斥量和信号量在其他进程也是可见的
    - 读写锁（Read-Write Lock）：对于读取频繁而仅仅偶尔写入数据的情况，读写锁更加高效
    - 条件变量（Condition Variable）：使用条件变量可以让许多线程一起等待某个事件的发生，当事件发生时，所有的线程可以一起恢复执行
  - **可重入（Reentrant）与线程安全**
    - 一个函数要被重入，只有两种情况：1. 多个线程同时执行这个函数 2. 函数自身（可能是经过多层调用之后）调用自身
    - 可重入的函数具备的特点：P. 28
  - 过度优化
    - 编译器做的过度优化可能会导致线程不安全：第一个问题是编译器为了提高速度将一个变量缓存到寄存器内而不写回，第二个问题是编译器可能为了效率交换毫不相干的两条相邻指令的执行顺序
    - 使用volatile关键字可以完美解决第一个问题
    - CPU的乱序执行能力让我们对多线程安全的努力变得异常困难，然而现在并不存在***可移植***的阻止换序的方法，可以尝试使用barrier
- 多线程的内部实现
  - 一对一模型：一个用户线程唯一对应一个内核线程
  - 多对一模型：将多个用户线程映射到一个内核线程上
  - 多对多模型：将多个用户线程映射到少数但不止一个内核线程上

<h1 id="static_linking"> 第2部分 静态链接 </h1>

## 2.1 编译和链接

### 程序构建（Build）

- 通常将编译和链接一步完成的过程称为**构建**（Build）
- 构建过程可以分解为4个步骤，分别是**预编译、编译、汇编和链接**
- 预编译
  - ```$ gcc -E hello.c -o hello.i```
  - 处理以“#”开始的预编译指令和宏
- 编译
  - 编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件
  - ```$ gcc -S hello.i -o hello.s```或者```$ /usr/lib/gcc/[PATH]/cc1 hello.c```
  - gcc进行预编译和编译实际上是调用的后台**预编译编译程序**来执行，对C语言来说是cc1，C++是cc1plus，Objective-C是cc1obj，fortran是f771，Java是jc1
- 汇编
  - 调用**汇编器**来完成：```$ as hello.s -o hello.o```
  - 或者```$ gcc -c hello.s -o hello.o```
- 链接
  - 使用**链接器**```ld```

### 编译步骤

- 编译过程一般可以分为6步：词法分析、语法分析、语义分析、源代码优化、代码生成和目标代码优化
- 词法分析将源代码的字符分割成一系列的**记号**（Token）
  - 扫描器运用一种类似于有限状态机的算法进行词法分析，程序```lex```是一个扫描器
- 语法分析器对由扫描器产生的记号进行语法分析，从而产生语法树
  - 采用了上下文无关语法（Context-free Grammar），生成以表达式为节点的树
  - 语法分析有一个现成的工具叫做yacc（Yet Another Compiler Compiler）
- 语义分析器分析语法树的表达式是否合法
  - 编译器能分析的是静态语义，即在编译期可以确定的语义
  - 静态语义通常包括声明和类型的匹配，类型的转换
  - 动态语义是在运行期才能确定的语义，比如将0作为除数
- 中间语言生成
  - 源代码级优化器在源代码级别进行优化，将语法树转换成中间代码
  - 中间代码有很多种类型，常见的有三地址码和P-代码
    - 最基本的三地址码是这样的：x = y ***op*** z
  - 中间代码使得编译器可以被分为前端和后端。编译器前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码
- 目标代码生成与优化
  - 代码生成器将中间代码转换成目标机器代码
  - 目标代码优化器对目标代码进行优化，比如选择合适的寻址方式、使用位移来代替乘法运算、删除多余的指令等

### 链接器

- 程序修改时重新计算各个目标的地址过程被叫做**重定位**（Relocation）
- **符号**（Symbol）这个概念随着汇编语言的普及迅速被使用，它用来表示一个地址，这个地址可能是一段子程序的起始地址，也可以是一个变量的起始地址
- 程序模块间会有符号引用，将模块拼接的过程称之为**链接**（Linking）
- 链接过程主要包括了**地址和空间分配**（Address and Storage Allocation）、**符号决议**（Symbol Resolution）和**重定位**（Relocation）等步骤
- 目标文件和库一起链接形成最终可执行文件，最常见的库就是**运行时库**（Runtime Library）
- 地址修正的过程叫做重定位，每个要被修正的地方叫一个重定位入口

## 2.2 目标文件

无论是可执行文件、目标文件或库，它们实际上都是一种基于段的文件或是这种文件的集合。（P. 95）

### 目标文件格式

- 动态链接库及静态链接库文件都按照可执行文件格式存储
- 现在PC平台流行的可执行文件存储格式主要是Windows下的PE(Portable Executable)和Linux的ELF(Exectuable Linkable Format)，它们都是COFF(Common file format)格式的变种
- ELF标准将ELF文件归为以下4类
  - 可重定位文件（Relocatable File）：如Linux的.o，Windows的.obj
  - 可执行文件（Executable File）：如/bin/bash，Windows的.exe
  - 共享目标文件（Shared Object File）：如Linux的.so，Windows的DLL
  - 核心转储文件（Core Dump File）：如Linux下的core dump
- 我们可以在Linux下使用```file```命令查看相应的文件格式

### 目标文件结构

- 目标文件一般包含文件头、代码段、数据段、BSS段等
- 程序指令（代码段）和程序数据（数据段、BSS段）分开的好处：(1)读写权限 (2)提高CPU缓存命中率 (3)指令共享内存
- ```objdump```可以用于查看各种目标文件结构和内容
  - ```$ objdump -h hello.o```查看目标文件头的信息
  - .text是代码段，.data是数据段，.bss是BSS段，.rodata是只读数据段，.comment是注释信息段，.note.GNU-stack是堆栈提示段
  - 代码段
    - ```$ objdump -s hello.o```将所有段以十六进制打印出来
    - ```$ objdump -d hello.o```反汇编可执行段
  - 数据段和只读数据段
    - .data段存放已经初始化了的全局静态变量和局部静态变量
    - .rodata段存放只读数据，一般是只读变量（如const变量）
  - BSS段存放未初始化的全局变量和静态变量
  - 其他段参考书中表3-2
- ```size```指令可以用于查看ELF文件各个段的长度

#### ELF文件结构

- 文件头
  - 可以通过```$ readelf -h hello.o```查看
  - 各字段的含义可以参考表3-3、3-4、3-5和3-6
- 段表
  - ```objdump -h```只把关键的段显示了出来，省略了辅助性的段
  - ```$ readelf -S hello.o```显示的才是真正的段表的结构
  - 各字段含义参考表3-7到表3-11
- 重定位表
- 字符串表
  - .strtab是字符串表，用来保存普通的字符串
  - .shstrtab是段字符串表，用来保存段表中用到的字符串，最常见的就是段名
- 符号表
  - 在链接中，我们将函数和变量统称为**符号**（Symbol），函数名或变量名就是符号名
  - readelf、objdump、nm等工具可以用来查看符号表
  - ELF文件中的符号表往往是文件中的一个段，段名一般叫.symtab
  - ```$ readelf -s hello.o```
- 调试表
  - GCC编译时加上-g参数会在目标文件中有调试信息
  - 在Linux下，可以用strip命令去掉ELF文件中的调试信息
    - ```$ strip foo```

### 链接的接口--符号

- 特殊符号
  - ld链接生成可执行文件时会为我们定义很多特殊符号
- 符号修饰与函数命名
  - C++通过命名空间来解决符号冲突的问题
  - 符号修饰：```c++filt```可以用来解析修饰后名称
- ```extern "C"```
  - 在C++中声明或定义一个C的符号
  - ```#ifdef __cplusplus```配合使用
- 弱符号与强符号
  - 对于C/C++来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号
  - 我们也可以通过GCC的```__attribute__((weak))```来定义一个强符号为弱符号
  - 强符号和弱符号都是针对定义的概念，而不是针对引用
  - 强符号不能被多次定义，弱符号可以
- **【弱引用与强引用】**
  - 在处理强引用时，如果没有找到该符号的定义，链接器会报符号未定义错误
  - 在处理弱引用时，如果符号有定义，则链接器将该符号的引用决议；如果符号未被定义，链接器对于该引用也不报错
  - 一般对于未定义的弱引用，链接器默认其为0，或者是一个特殊的值
  - GCC中，弱引用关键字为```__attribute__((weakref))```
  - 弱符号和弱引用对于库来说十分有用，比如
    - 库中定义的弱符号可以被用户定义的强符号覆盖
    - 将某些扩展功能模块定义为弱引用，使得无论有没有这个模块都能正常链接
    - 程序既支持单线程也支持多线程使用时

## 2.3 静态链接

## 2.4 Windows平台的目标文件和可执行文件格式

<h1 id="dynamic_linking"> 第3部分 装载与动态链接 </h1>

<h1 id="runtime_library"> 第4部分 库与运行库 </h1>

<h1 id="index"> 指令索引 </h1>
